## 동적프로그래밍 5: 재귀곱셈

### 연산자를 사용하지 않고 양의 정수 두 개를 곱하는 재귀 함수를 작성하라. 
### 덧셈, 뺄셈, 비트 시프팅 연산자를 사용할 수 있지만 이들의 사용횟수를 최소화해야한다.


HINT: 곱셉의 의미. 하나의 수를 몇번 더하는지에 대한 개념. 
아니면 가로 세로 고정된 셀들로 이루어진 격자판에서 각 셀의 개수.

8 * 4 = 8 + 8 + 8 + 8

이와 같이 곱셈을 한다는 것은 얼마나 더해주냐는 것과 동일하다.
따라서 같은 수가 몇개가 있는지 카운트 하는 것으로 곱셉 연산자를 대신할 수 있다.


#### solution 1. GridProductBrute

격자판에서의 셀의 개수를 세는 방법?
절반을 센 뒤 이를 곱절로 만드는 과정을 재귀적으로 처리.
만약 값이 짝수일때만 이방법이 동작.
홀수인 경우에는 곱절이 될 수 없으므로 하나씩 세서 더해줌.

#### solution 2. GridProductRecurr

재귀 동작에서 중복된 부분을 찾을 수 있다.
```
minProduct(17, 23)
    minProduct(8, 23)
        minProduct(4, 23) * 2

    ...

    + minProduct(9, 23)
        minProduct(4, 23)
    ...

        + minProduct(5, 23)
    ...
```

두번째 minProduct(4, 23) 은 이전 호출이 있었는지 모르기 때문에 같은 일을 반복하게 됨. 
그 결과를 캐시에 넣어 반복된 작업을 제거해줌.


#### solution 3. GridProductImprov.

해법 2를 보면 짝수일때 minProduct를 호출하는 경우가 홀수일때보다 더 빠르다. 
예를 들어 minProduct(30, 35) 를 호출하면 minProduct(15, 35)를 호출한뒤 결과에 두 배를 한다.
하지만 minProduct(31, 35)를 호출하면 minProduct(15, 35) 와 minProduct(16, 35) 두 개를 호출해야 한다.

이는 불필요한 연산이다. 대신 이렇게 할 수 있다.

```
minProduct(31, 35) = 2 * minProduct(15, 35) + 35
결국 31 = 2 * 15 + 1 이고, 따라서 31 * 35 = 2**15*35 + 35 가 된다.
```

해법은 짝수일 경우에는 재귀적으로 smaller를 2로 나눈 뒤에 그 결과를 곱절해주고, 
홀수인 경우에는 짝수와 동일하게 동작하지만 마지막에 bigger를 한 번 더 더해주면 된다.

같은 호출을 계속하지 않으므로 캐시에 저장하지 않아도 된다.

**이 경우 알고리즘의 시간 복잡도는 O(log s)**